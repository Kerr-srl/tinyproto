<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.9.1"/>
<title>Tiny protocol: Tiny advanced API functions</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Tiny protocol
   &#160;<span id="projectnumber">0.5.1</span>
   </div>
   <div id="projectbrief">Tiny communication protocol for microcontrollers</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.9.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Tiny advanced API functions</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gac5cabf56a5b22e96036b9e5bff926f1d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ADVANCED__API.html#gac5cabf56a5b22e96036b9e5bff926f1d">tiny_enable_uid</a> (<a class="el" href="structSTinyData.html">STinyData</a> *handle, uint8_t on)</td></tr>
<tr class="memdesc:gac5cabf56a5b22e96036b9e5bff926f1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">The function enables uid support. Enables uid support. The function affects on tiny_on_rx_byte and on_frame_cb_t behavior.  <a href="#gac5cabf56a5b22e96036b9e5bff926f1d">More...</a><br /></td></tr>
<tr class="separator:gac5cabf56a5b22e96036b9e5bff926f1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5e66725a2818491d4e2b1134951d9229"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ADVANCED__API.html#ga5e66725a2818491d4e2b1134951d9229">tiny_set_fcs_bits</a> (<a class="el" href="structSTinyData.html">STinyData</a> *handle, uint8_t bits)</td></tr>
<tr class="separator:ga5e66725a2818491d4e2b1134951d9229"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaf9bf6423bd0b8388c3387225b805278"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ADVANCED__API.html#gaaf9bf6423bd0b8388c3387225b805278">tiny_on_rx_byte</a> (<a class="el" href="structSTinyData.html">STinyData</a> *handle, uint8_t *pbuf, int len, uint8_t byte)</td></tr>
<tr class="memdesc:gaaf9bf6423bd0b8388c3387225b805278"><td class="mdescLeft">&#160;</td><td class="mdescRight">The function processes one rx byte. Used in event-based mode. This function processes single received byte. If new frame is completely received, read_cb handler is called and application can take actions on receive frame. Refer to tiny_set_callbacks.  <a href="#gaaf9bf6423bd0b8388c3387225b805278">More...</a><br /></td></tr>
<tr class="separator:gaaf9bf6423bd0b8388c3387225b805278"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga159189fa29f3eaa79a76a3fa87b31084"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ADVANCED__API.html#ga159189fa29f3eaa79a76a3fa87b31084">tiny_send_start</a> (<a class="el" href="structSTinyData.html">STinyData</a> *handle, uint8_t flags)</td></tr>
<tr class="memdesc:ga159189fa29f3eaa79a76a3fa87b31084"><td class="mdescLeft">&#160;</td><td class="mdescRight">initiates sending of a new frame  <a href="#ga159189fa29f3eaa79a76a3fa87b31084">More...</a><br /></td></tr>
<tr class="separator:ga159189fa29f3eaa79a76a3fa87b31084"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabe04a4e76adc5421deac4e3699a15646"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ADVANCED__API.html#gabe04a4e76adc5421deac4e3699a15646">tiny_send_buffer</a> (<a class="el" href="structSTinyData.html">STinyData</a> *handle, uint8_t *pbuf, int len, uint8_t flags)</td></tr>
<tr class="memdesc:gabe04a4e76adc5421deac4e3699a15646"><td class="mdescLeft">&#160;</td><td class="mdescRight">sends user provided data in the body of the frame  <a href="#gabe04a4e76adc5421deac4e3699a15646">More...</a><br /></td></tr>
<tr class="separator:gabe04a4e76adc5421deac4e3699a15646"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2e85c7e9efb0bbe9c6adfd923ec7c73c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ADVANCED__API.html#ga2e85c7e9efb0bbe9c6adfd923ec7c73c">tiny_send_end</a> (<a class="el" href="structSTinyData.html">STinyData</a> *handle, uint8_t flags)</td></tr>
<tr class="memdesc:ga2e85c7e9efb0bbe9c6adfd923ec7c73c"><td class="mdescLeft">&#160;</td><td class="mdescRight">completes sending of a new frame  <a href="#ga2e85c7e9efb0bbe9c6adfd923ec7c73c">More...</a><br /></td></tr>
<tr class="separator:ga2e85c7e9efb0bbe9c6adfd923ec7c73c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga73c9f1cfb0948bd559d3704749db540b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ADVANCED__API.html#ga73c9f1cfb0948bd559d3704749db540b">tiny_send_terminate</a> (<a class="el" href="structSTinyData.html">STinyData</a> *handle)</td></tr>
<tr class="memdesc:ga73c9f1cfb0948bd559d3704749db540b"><td class="mdescLeft">&#160;</td><td class="mdescRight">terminates send operation  <a href="#ga73c9f1cfb0948bd559d3704749db540b">More...</a><br /></td></tr>
<tr class="separator:ga73c9f1cfb0948bd559d3704749db540b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2f0547115de5b96a828d79f5491d22fa"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ADVANCED__API.html#ga2f0547115de5b96a828d79f5491d22fa">tiny_read_start</a> (<a class="el" href="structSTinyData.html">STinyData</a> *handle, uint8_t flags)</td></tr>
<tr class="memdesc:ga2f0547115de5b96a828d79f5491d22fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">initiates receiving of a new frame  <a href="#ga2f0547115de5b96a828d79f5491d22fa">More...</a><br /></td></tr>
<tr class="separator:ga2f0547115de5b96a828d79f5491d22fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gade4e07eb12b8e32e6dd0c7b9757e8f39"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ADVANCED__API.html#gade4e07eb12b8e32e6dd0c7b9757e8f39">tiny_read_buffer</a> (<a class="el" href="structSTinyData.html">STinyData</a> *handle, uint8_t *pbuf, int len, uint8_t flags)</td></tr>
<tr class="memdesc:gade4e07eb12b8e32e6dd0c7b9757e8f39"><td class="mdescLeft">&#160;</td><td class="mdescRight">reads frame payload to provided buffer  <a href="#gade4e07eb12b8e32e6dd0c7b9757e8f39">More...</a><br /></td></tr>
<tr class="separator:gade4e07eb12b8e32e6dd0c7b9757e8f39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaab48caab81a46d74fb52f2afb2649b61"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ADVANCED__API.html#gaab48caab81a46d74fb52f2afb2649b61">tiny_read_terminate</a> (<a class="el" href="structSTinyData.html">STinyData</a> *handle)</td></tr>
<tr class="memdesc:gaab48caab81a46d74fb52f2afb2649b61"><td class="mdescLeft">&#160;</td><td class="mdescRight">terminates read operation  <a href="#gaab48caab81a46d74fb52f2afb2649b61">More...</a><br /></td></tr>
<tr class="separator:gaab48caab81a46d74fb52f2afb2649b61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac318682c20279f9f20ffc6f636a7f1c9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ADVANCED__API.html#gac318682c20279f9f20ffc6f636a7f1c9">tiny_lock</a> (<a class="el" href="structSTinyData.html">STinyData</a> *handle, uint8_t flags)</td></tr>
<tr class="memdesc:gac318682c20279f9f20ffc6f636a7f1c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">locks Tiny state machine for send operations  <a href="#gac318682c20279f9f20ffc6f636a7f1c9">More...</a><br /></td></tr>
<tr class="separator:gac318682c20279f9f20ffc6f636a7f1c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae4bfad55a4ef5814a5af50f044f6d7cd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ADVANCED__API.html#gae4bfad55a4ef5814a5af50f044f6d7cd">tiny_unlock</a> (<a class="el" href="structSTinyData.html">STinyData</a> *handle)</td></tr>
<tr class="memdesc:gae4bfad55a4ef5814a5af50f044f6d7cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">unlock Tiny state machine for send operations  <a href="#gae4bfad55a4ef5814a5af50f044f6d7cd">More...</a><br /></td></tr>
<tr class="separator:gae4bfad55a4ef5814a5af50f044f6d7cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac562103dd1699b82fddf29dccdc0ec7c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ADVANCED__API.html#gac562103dd1699b82fddf29dccdc0ec7c">tiny_set_callbacks</a> (<a class="el" href="structSTinyData.html">STinyData</a> *handle, <a class="el" href="tiny__layer2_8h.html#ad6bf709565b8aecb9e6ecf196f219d54">on_frame_cb_t</a> read_cb, <a class="el" href="tiny__layer2_8h.html#ad6bf709565b8aecb9e6ecf196f219d54">on_frame_cb_t</a> send_cb)</td></tr>
<tr class="memdesc:gac562103dd1699b82fddf29dccdc0ec7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">set callbacks for processing frames The function sets callback procs for specified Tiny channel. callbacks will receive all data being sent or received.  <a href="#gac562103dd1699b82fddf29dccdc0ec7c">More...</a><br /></td></tr>
<tr class="separator:gac562103dd1699b82fddf29dccdc0ec7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabe38a1f81966f6901eb2f6969b568298"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ADVANCED__API.html#gabe38a1f81966f6901eb2f6969b568298">tiny_get_callbacks</a> (<a class="el" href="structSTinyData.html">STinyData</a> *handle, <a class="el" href="tiny__layer2_8h.html#ad6bf709565b8aecb9e6ecf196f219d54">on_frame_cb_t</a> *read_cb, <a class="el" href="tiny__layer2_8h.html#ad6bf709565b8aecb9e6ecf196f219d54">on_frame_cb_t</a> *send_cb)</td></tr>
<tr class="memdesc:gabe38a1f81966f6901eb2f6969b568298"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns callbacks assigned for frame processing The function returns set callbacks.  <a href="#gabe38a1f81966f6901eb2f6969b568298">More...</a><br /></td></tr>
<tr class="separator:gabe38a1f81966f6901eb2f6969b568298"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5f61774b2027a91f772f31d943acdd3f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ADVANCED__API.html#ga5f61774b2027a91f772f31d943acdd3f">tiny_get_stat</a> (<a class="el" href="structSTinyData.html">STinyData</a> *handle, <a class="el" href="structSTinyStats.html">STinyStats</a> *stat)</td></tr>
<tr class="separator:ga5f61774b2027a91f772f31d943acdd3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac75ee03ea3691b0a8bf842d764b342d9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ADVANCED__API.html#gac75ee03ea3691b0a8bf842d764b342d9">tiny_clear_stat</a> (<a class="el" href="structSTinyData.html">STinyData</a> *handle)</td></tr>
<tr class="separator:gac75ee03ea3691b0a8bf842d764b342d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="gac75ee03ea3691b0a8bf842d764b342d9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int tiny_clear_stat </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSTinyData.html">STinyData</a> *&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The function clears Tiny statistics. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>- pointer to Tiny data. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__ERROR__FLAGS.html#ga541a9e67a84e39595ad647d641c4df2e" title="Some invalid data passed to Tiny API function. ">TINY_ERR_INVALID_DATA</a> </dd>
<dd>
<a class="el" href="group__ERROR__FLAGS.html#ga69c869a686b67bf0b7b8115599515d61" title="No error. For tiny_send and tiny_read functions, this means, no data sent or received. ">TINY_NO_ERROR</a> </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>TINY_ERR_INVALID_DATA, TINY_NO_ERROR. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This function is not thread safe. </dd></dl>

</div>
</div>
<a class="anchor" id="gac5cabf56a5b22e96036b9e5bff926f1d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tiny_enable_uid </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSTinyData.html">STinyData</a> *&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>on</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The function enables uid support. Enables uid support. The function affects on tiny_on_rx_byte and on_frame_cb_t behavior. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>- pointer to Tiny structure </td></tr>
    <tr><td class="paramname">on</td><td>- 0 to disable UID support. 1 to enable UID support. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>This function is not thread safe. </dd></dl>

</div>
</div>
<a class="anchor" id="gabe38a1f81966f6901eb2f6969b568298"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int tiny_get_callbacks </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSTinyData.html">STinyData</a> *&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="tiny__layer2_8h.html#ad6bf709565b8aecb9e6ecf196f219d54">on_frame_cb_t</a> *&#160;</td>
          <td class="paramname"><em>read_cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="tiny__layer2_8h.html#ad6bf709565b8aecb9e6ecf196f219d54">on_frame_cb_t</a> *&#160;</td>
          <td class="paramname"><em>send_cb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns callbacks assigned for frame processing The function returns set callbacks. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>- pointer to Tiny data. </td></tr>
    <tr><td class="paramname">read_cb</td><td>- pointer to store read callback to. can be NULL. </td></tr>
    <tr><td class="paramname">send_cb</td><td>- pointer to store write callback to. can be NULL. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TINY_ERR_INVALID_DATA, TINY_NO_ERROR. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This function is thread safe. </dd></dl>

</div>
</div>
<a class="anchor" id="ga5f61774b2027a91f772f31d943acdd3f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int tiny_get_stat </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSTinyData.html">STinyData</a> *&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSTinyStats.html">STinyStats</a> *&#160;</td>
          <td class="paramname"><em>stat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The function returns statistics per communication connection. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>- pointer to Tiny data. </td></tr>
    <tr><td class="paramname">stat</td><td>- pointer of stucture to fill. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__ERROR__FLAGS.html#ga541a9e67a84e39595ad647d641c4df2e" title="Some invalid data passed to Tiny API function. ">TINY_ERR_INVALID_DATA</a> </dd>
<dd>
<a class="el" href="group__ERROR__FLAGS.html#ga69c869a686b67bf0b7b8115599515d61" title="No error. For tiny_send and tiny_read functions, this means, no data sent or received. ">TINY_NO_ERROR</a> </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>TINY_ERR_INVALID_DATA, TINY_NO_ERROR. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This function is not thread safe. </dd></dl>

</div>
</div>
<a class="anchor" id="gac318682c20279f9f20ffc6f636a7f1c9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int tiny_lock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSTinyData.html">STinyData</a> *&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>locks Tiny state machine for send operations </p>
<p>This function should be used to perform send operation from parallel threads.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>- pointer to Tiny data </td></tr>
    <tr><td class="paramname">flags</td><td>- TINY_FLAG_NO_WAIT or TINY_FLAG_WAIT_FOREVER </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TINY_SUCCESS or TINY_ERR_FAILED. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This function is thread safe. </dd></dl>

</div>
</div>
<a class="anchor" id="gaaf9bf6423bd0b8388c3387225b805278"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int tiny_on_rx_byte </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSTinyData.html">STinyData</a> *&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>pbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>byte</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The function processes one rx byte. Used in event-based mode. This function processes single received byte. If new frame is completely received, read_cb handler is called and application can take actions on receive frame. Refer to tiny_set_callbacks. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>- pointer to Tiny data </td></tr>
    <tr><td class="paramname">pbuf</td><td>- pointer to a buffer to store bytes being received. </td></tr>
    <tr><td class="paramname">len</td><td>- maximum size of receiver buffer. </td></tr>
    <tr><td class="paramname">byte</td><td>- byte received from communication channel. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TINY_NO_ERROR if byte is processed successfully and more bytes is required. TINY_ERR_OUT_OF_SYNC if sync error occured on communication channel TINY_ERR_DATA_TOO_LARGE TINY_SUCCESS </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This function may be used in interrupt handlers. This depends on on_frame_cb_t handler set for receive operations, which is implemented by applications. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>to not perform blocking send operations in receive handler if you're using tiny_on_rx_byte in interrupt handler. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This function is not thread safe. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="tiny__layer2_8h.html#ad6bf709565b8aecb9e6ecf196f219d54">on_frame_cb_t</a> </dd>
<dd>
<a class="el" href="group__ADVANCED__API.html#gac562103dd1699b82fddf29dccdc0ec7c" title="set callbacks for processing frames The function sets callback procs for specified Tiny channel...">tiny_set_callbacks</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="gade4e07eb12b8e32e6dd0c7b9757e8f39"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int tiny_read_buffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSTinyData.html">STinyData</a> *&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>pbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>reads frame payload to provided buffer </p>
<p>The function reads frame payload to provided buffer. Without TINY_FLAG_READ_ALL the function reads no more byte than len, passed to the function. If provided buffer is filled completely, but there are more bytes to read, then the function returns TINY_ERR_DATA_TOO_LARGE (indicating that tiny_read_buffer must be called once again for next portion of bytes). Otherwise, <a class="el" href="group__ADVANCED__API.html#gade4e07eb12b8e32e6dd0c7b9757e8f39" title="reads frame payload to provided buffer ">tiny_read_buffer()</a> returns number of bytes contained in the received frame.</p>
<p>If frame payload is too big to fit to provided buffer, but it is required to read whole frame from the communication channel till the end marker, TINY_FLAG_READ_ALL can be specified. In this case, the function will fill provided buffer with frame bytes, and bytes in the end of frame will be lost. The function returns TINY_ERR_DATA_TOO_LARGE, but this means that frame data didn't fit to buffer, and frame is completely received.</p>
<p>If function is in non-blocking mode, it may return immediately with TINY_NO_ERROR. In this case a user should call this function later with the same parameters.</p>
<dl class="section note"><dt>Note</dt><dd>if flags field is set to TINY_FLAG_NO_WAIT, then this function may remember pbuf pointer and return immediately. So, it is responsibility of the caller to make pbuf to be available all the time until block of data is received.</dd>
<dd>
The read data can be considered as valid, only when last buffer is successfully read. That is tiny_read_buffer function returns length of read bytes (&gt;0), or tiny_read_buffer function returns TINY_ERR_DATA_TOO_LARGE if TINY_FLAG_READ_ALL flag is specified.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>- pointer to Tiny data. </td></tr>
    <tr><td class="paramname">pbuf</td><td>- pointer to buffer to read frame data to. </td></tr>
    <tr><td class="paramname">len</td><td>- length of the provided buffer in bytes. </td></tr>
    <tr><td class="paramname">flags</td><td>- TINY_FLAG_NO_WAIT or TINY_FLAG_WAIT_FOREVER, can be combined with TINY_FLAG_READ_ALL </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>length in bytes of data received if executed successfully TINY_NO_ERROR if non-blocking operation is requested and the channel is busy TINY_ERR_FAILED if writing to the channel failed TINY_ERR_INVALID_DATA if invalid handle is passed TINY_ERR_DATA_TOO_LARGE if all data do not fit in buffer.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__ERROR__FLAGS.html#ga16cd043c890ed1fa381b3a20f75a626c" title="Tiny operation successful. Only tiny_send_start and tiny_read_start functions return this code...">TINY_SUCCESS</a> </dd>
<dd>
<a class="el" href="group__ERROR__FLAGS.html#ga541a9e67a84e39595ad647d641c4df2e" title="Some invalid data passed to Tiny API function. ">TINY_ERR_INVALID_DATA</a> </dd>
<dd>
<a class="el" href="group__ERROR__FLAGS.html#ga84e6ca143550038e1a71cf36078d1926" title="Timeout. ">TINY_ERR_FAILED</a> </dd>
<dd>
<a class="el" href="group__ERROR__FLAGS.html#ga7bbe7440d11ad304b0af68e011f4eab7" title="Data too large to fit the user buffer, valid for tiny_read function. ">TINY_ERR_DATA_TOO_LARGE</a> </dd>
<dd>
<a class="el" href="group__FLAGS__GROUP.html#gadadd60eb21d7949e6d097ad36aab9b2e" title="This flag makes tiny API functions perform as non-blocking. ">TINY_FLAG_NO_WAIT</a> </dd>
<dd>
<a class="el" href="group__FLAGS__GROUP.html#ga3a34267804581c5709d03f52d232b307" title="This flag makes tiny API functions perform in blocking mode. ">TINY_FLAG_WAIT_FOREVER</a> </dd>
<dd>
<a class="el" href="group__FLAGS__GROUP.html#gae41123cfeed375e618a4152c9bbd0d6d" title="This flag makes tiny_read function to read whole frame event if it doesn&#39;t fit the buffer...">TINY_FLAG_READ_ALL</a> </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>any failed read operation (tiny_read_buffer), except TINY_ERR_DATA_TOO_LARGE case, must be terminated with tiny_read_terminate. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This function is not thread safe. </dd></dl>

</div>
</div>
<a class="anchor" id="ga2f0547115de5b96a828d79f5491d22fa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int tiny_read_start </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSTinyData.html">STinyData</a> *&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>initiates receiving of a new frame </p>
<p>The function initiates receiving of a new frame. It waits for frame start marker in communication channel. If any character different from frame start marker is read from communication channel, it returns TINY_ERR_OUT_OF_SYNC. Just call it once more in this case. If the function is executed successfully, then tiny_read_buffer can be used to read user data from communication channel.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>- pointer to Tiny data. </td></tr>
    <tr><td class="paramname">flags</td><td>- TINY_FLAG_NO_WAIT, TINY_FLAG_WAIT_FOREVER. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TINY_SUCCESS if new frame is detected in communication channel. TINY_NO_ERROR if nothing is awaiting in the communication channel and function is in non-blocking mode TINY_ERR_FAILED if writing to the channel failed TINY_ERR_INVALID_DATA if invalid handle is passed TINY_ERR_OUT_OF_SYNC if not valid byte is received</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__ERROR__FLAGS.html#ga16cd043c890ed1fa381b3a20f75a626c" title="Tiny operation successful. Only tiny_send_start and tiny_read_start functions return this code...">TINY_SUCCESS</a> </dd>
<dd>
<a class="el" href="group__ERROR__FLAGS.html#ga541a9e67a84e39595ad647d641c4df2e" title="Some invalid data passed to Tiny API function. ">TINY_ERR_INVALID_DATA</a> </dd>
<dd>
<a class="el" href="group__ERROR__FLAGS.html#ga69c869a686b67bf0b7b8115599515d61" title="No error. For tiny_send and tiny_read functions, this means, no data sent or received. ">TINY_NO_ERROR</a> </dd>
<dd>
<a class="el" href="group__ERROR__FLAGS.html#gae1949de45d9c478830dad9c9b996193a" title="Out of sync - received some data, which are not part of the frame (tiny_read) ">TINY_ERR_OUT_OF_SYNC</a> </dd>
<dd>
<a class="el" href="group__ERROR__FLAGS.html#ga84e6ca143550038e1a71cf36078d1926" title="Timeout. ">TINY_ERR_FAILED</a> </dd>
<dd>
<a class="el" href="group__FLAGS__GROUP.html#gadadd60eb21d7949e6d097ad36aab9b2e" title="This flag makes tiny API functions perform as non-blocking. ">TINY_FLAG_NO_WAIT</a> </dd>
<dd>
<a class="el" href="group__FLAGS__GROUP.html#ga3a34267804581c5709d03f52d232b307" title="This flag makes tiny API functions perform in blocking mode. ">TINY_FLAG_WAIT_FOREVER</a> </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This function is not thread safe. </dd></dl>

</div>
</div>
<a class="anchor" id="gaab48caab81a46d74fb52f2afb2649b61"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tiny_read_terminate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSTinyData.html">STinyData</a> *&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>terminates read operation </p>
<p>This function is to be used, when it is required to reset receive state in case of communication error.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>- pointer to Tiny data. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>This function is not thread safe. </dd></dl>

</div>
</div>
<a class="anchor" id="gabe04a4e76adc5421deac4e3699a15646"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int tiny_send_buffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSTinyData.html">STinyData</a> *&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>pbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>sends user provided data in the body of the frame </p>
<p>The function sends user provided data (payload) in the body of the frame. It is possible to send several buffers if the single frame. In this case the receiver side will receive all buffers as one data block. Extended read functions allow to read data of the frame to several buffers. If function is in non-blocking mode, it may return immediately with TINY_NO_ERROR. In this case a user should call this function later with the same parameters.</p>
<dl class="section note"><dt>Note</dt><dd>if flags field is set to TINY_FLAG_NO_WAIT, then this function may remember pbuf pointer and return immediately. So, it is responsibility of the caller to make pbuf data to be available all the time until frame is sent.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>- pointer to Tiny data. </td></tr>
    <tr><td class="paramname">pbuf</td><td>- pointer to buffer with data to send. </td></tr>
    <tr><td class="paramname">len</td><td>- length of the data to send in bytes. </td></tr>
    <tr><td class="paramname">flags</td><td>- TINY_FLAG_NO_WAIT or TINY_FLAG_WAIT_FOREVER </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>length in bytes of data sent if executed successfully TINY_NO_ERROR if non-blocking operation is requested and the channel is busy TINY_ERR_FAILED if writing to the channel failed TINY_ERR_INVALID_DATA if invalid handle is passed</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__ERROR__FLAGS.html#ga16cd043c890ed1fa381b3a20f75a626c" title="Tiny operation successful. Only tiny_send_start and tiny_read_start functions return this code...">TINY_SUCCESS</a> </dd>
<dd>
<a class="el" href="group__ERROR__FLAGS.html#ga541a9e67a84e39595ad647d641c4df2e" title="Some invalid data passed to Tiny API function. ">TINY_ERR_INVALID_DATA</a> </dd>
<dd>
<a class="el" href="group__ERROR__FLAGS.html#gac9ba8076a1eb8613e8d1f07629ff0cd1" title="Timeout happened. The function must be called once again. ">TINY_ERR_TIMEOUT</a> </dd>
<dd>
<a class="el" href="group__ERROR__FLAGS.html#ga84e6ca143550038e1a71cf36078d1926" title="Timeout. ">TINY_ERR_FAILED</a> </dd>
<dd>
<a class="el" href="group__FLAGS__GROUP.html#gadadd60eb21d7949e6d097ad36aab9b2e" title="This flag makes tiny API functions perform as non-blocking. ">TINY_FLAG_NO_WAIT</a> </dd>
<dd>
<a class="el" href="group__FLAGS__GROUP.html#ga3a34267804581c5709d03f52d232b307" title="This flag makes tiny API functions perform in blocking mode. ">TINY_FLAG_WAIT_FOREVER</a> </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>any failed send operation (tiny_send_buffer, tiny_send_end), except timeout cases, must be terminated with tiny_send_terminate, otherwise the thread can be blocked. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This function is not thread safe. </dd></dl>

</div>
</div>
<a class="anchor" id="ga2e85c7e9efb0bbe9c6adfd923ec7c73c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int tiny_send_end </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSTinyData.html">STinyData</a> *&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>completes sending of a new frame </p>
<p>The function completes sending of a new frame by writing FCS block and frame end marker to communication channel. If the function is executed successfully, then tiny_send_start can be executed again.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>- pointer to Tiny data. </td></tr>
    <tr><td class="paramname">flags</td><td>- TINY_FLAG_NO_WAIT or TINY_FLAG_WAIT_FOREVER </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TINY_SUCCESS if send frame is completed successfully. TINY_NO_ERROR if non-blocking operation is requested and the channel is busy TINY_ERR_FAILED if writing to the channel failed TINY_ERR_INVALID_DATA if invalid handle is passed</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__ERROR__FLAGS.html#ga16cd043c890ed1fa381b3a20f75a626c" title="Tiny operation successful. Only tiny_send_start and tiny_read_start functions return this code...">TINY_SUCCESS</a> </dd>
<dd>
<a class="el" href="group__ERROR__FLAGS.html#ga69c869a686b67bf0b7b8115599515d61" title="No error. For tiny_send and tiny_read functions, this means, no data sent or received. ">TINY_NO_ERROR</a> </dd>
<dd>
<a class="el" href="group__ERROR__FLAGS.html#ga541a9e67a84e39595ad647d641c4df2e" title="Some invalid data passed to Tiny API function. ">TINY_ERR_INVALID_DATA</a> </dd>
<dd>
<a class="el" href="group__ERROR__FLAGS.html#gac9ba8076a1eb8613e8d1f07629ff0cd1" title="Timeout happened. The function must be called once again. ">TINY_ERR_TIMEOUT</a> </dd>
<dd>
<a class="el" href="group__ERROR__FLAGS.html#ga84e6ca143550038e1a71cf36078d1926" title="Timeout. ">TINY_ERR_FAILED</a> </dd>
<dd>
<a class="el" href="group__FLAGS__GROUP.html#gadadd60eb21d7949e6d097ad36aab9b2e" title="This flag makes tiny API functions perform as non-blocking. ">TINY_FLAG_NO_WAIT</a> </dd>
<dd>
<a class="el" href="group__FLAGS__GROUP.html#ga3a34267804581c5709d03f52d232b307" title="This flag makes tiny API functions perform in blocking mode. ">TINY_FLAG_WAIT_FOREVER</a> </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This function is not thread safe.</dd></dl>
<p>Returns TINY_SUCCESS if frame sent is competed negative value in case of error </p>

</div>
</div>
<a class="anchor" id="ga159189fa29f3eaa79a76a3fa87b31084"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int tiny_send_start </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSTinyData.html">STinyData</a> *&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>initiates sending of a new frame </p>
<p>The function initiates sending of a new frame by writing frame start marker to communication channel. If the function is executed successfully, then tiny_send_buffer and tiny_send_end can be used to pass the data. If platform supports mutexes, the function locks internal mutex automatically.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>- pointer to Tiny data. </td></tr>
    <tr><td class="paramname">flags</td><td>- TINY_FLAG_NO_WAIT or TINY_FLAG_WAIT_FOREVER </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TINY_SUCCESS if new frame transmission is started successfully TINY_ERR_TIMEOUT if non-blocking operation is requested and the channel is busy TINY_ERR_FAILED if writing to the channel failed TINY_ERR_INVALID_DATA if invalid handle is passed</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__ERROR__FLAGS.html#ga16cd043c890ed1fa381b3a20f75a626c" title="Tiny operation successful. Only tiny_send_start and tiny_read_start functions return this code...">TINY_SUCCESS</a> </dd>
<dd>
<a class="el" href="group__ERROR__FLAGS.html#ga541a9e67a84e39595ad647d641c4df2e" title="Some invalid data passed to Tiny API function. ">TINY_ERR_INVALID_DATA</a> </dd>
<dd>
<a class="el" href="group__ERROR__FLAGS.html#gac9ba8076a1eb8613e8d1f07629ff0cd1" title="Timeout happened. The function must be called once again. ">TINY_ERR_TIMEOUT</a> </dd>
<dd>
<a class="el" href="group__ERROR__FLAGS.html#ga84e6ca143550038e1a71cf36078d1926" title="Timeout. ">TINY_ERR_FAILED</a> </dd>
<dd>
<a class="el" href="group__FLAGS__GROUP.html#gadadd60eb21d7949e6d097ad36aab9b2e" title="This flag makes tiny API functions perform as non-blocking. ">TINY_FLAG_NO_WAIT</a> </dd>
<dd>
<a class="el" href="group__FLAGS__GROUP.html#ga3a34267804581c5709d03f52d232b307" title="This flag makes tiny API functions perform in blocking mode. ">TINY_FLAG_WAIT_FOREVER</a> </dd>
<dd>
<a class="el" href="group__ADVANCED__API.html#gac318682c20279f9f20ffc6f636a7f1c9" title="locks Tiny state machine for send operations ">tiny_lock</a> </dd>
<dd>
<a class="el" href="group__ADVANCED__API.html#gae4bfad55a4ef5814a5af50f044f6d7cd" title="unlock Tiny state machine for send operations ">tiny_unlock</a> </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This function is thread safe. </dd></dl>

</div>
</div>
<a class="anchor" id="ga73c9f1cfb0948bd559d3704749db540b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tiny_send_terminate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSTinyData.html">STinyData</a> *&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>terminates send operation </p>
<p>This function is to be used, when it is required to reset send state in case of communication error</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>- pointer to Tiny data. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gac562103dd1699b82fddf29dccdc0ec7c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int tiny_set_callbacks </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSTinyData.html">STinyData</a> *&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="tiny__layer2_8h.html#ad6bf709565b8aecb9e6ecf196f219d54">on_frame_cb_t</a>&#160;</td>
          <td class="paramname"><em>read_cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="tiny__layer2_8h.html#ad6bf709565b8aecb9e6ecf196f219d54">on_frame_cb_t</a>&#160;</td>
          <td class="paramname"><em>send_cb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>set callbacks for processing frames The function sets callback procs for specified Tiny channel. callbacks will receive all data being sent or received. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>- pointer to Tiny data. </td></tr>
    <tr><td class="paramname">read_cb</td><td>- pointer to callback function. </td></tr>
    <tr><td class="paramname">send_cb</td><td>- pointer to callback function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TINY_ERR_INVALID_DATA, TINY_NO_ERROR. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This function is thread safe. </dd></dl>

</div>
</div>
<a class="anchor" id="ga5e66725a2818491d4e2b1134951d9229"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int tiny_set_fcs_bits </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSTinyData.html">STinyData</a> *&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>bits</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The function sets number of bits used for fcs </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>- pointer to Tiny structure </td></tr>
    <tr><td class="paramname">bits</td><td>- number of bits to use for fcs: 16 or 32. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TINY_ERR_FAILED TINY_NO_ERROR </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This function is not thread safe. </dd></dl>

</div>
</div>
<a class="anchor" id="gae4bfad55a4ef5814a5af50f044f6d7cd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tiny_unlock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSTinyData.html">STinyData</a> *&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>unlock Tiny state machine for send operations </p>
<p>This function should be used to perform send operation from parallel threads to unlock parallel threads.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>- pointer to Tiny data. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>This function is thread safe. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.9.1
</small></address>
</body>
</html>
